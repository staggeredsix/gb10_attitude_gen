<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LTX-2 Fever Dream + Mood Mirror</title>
    <style>
      body {
        font-family: "Inter", "Segoe UI", sans-serif;
        background: #0b0d14;
        color: #e6e9f2;
        margin: 0;
        padding: 0;
      }
      header {
        padding: 24px 32px;
        background: #131826;
        border-bottom: 1px solid #1f2636;
      }
      main {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 24px;
        padding: 24px 32px;
      }
      .panel {
        background: #121522;
        border-radius: 12px;
        padding: 16px;
        border: 1px solid #1f2636;
      }
      label {
        display: block;
        font-size: 0.85rem;
        margin-top: 12px;
        margin-bottom: 4px;
        color: #b8c0d8;
      }
      input,
      textarea,
      select,
      button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #2b3247;
        background: #0d111c;
        color: #e6e9f2;
      }
      textarea {
        min-height: 70px;
      }
      button {
        background: #4b7bff;
        border: none;
        font-weight: 600;
        cursor: pointer;
      }
      button:hover {
        background: #3b6af0;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 16px;
      }
      .stream {
        background: #0d111c;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid #20263b;
      }
      .stream img {
        width: 100%;
        display: block;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .status {
        margin-top: 12px;
        font-size: 0.85rem;
        color: #9aa4bf;
      }
      .mood-values {
        font-size: 0.85rem;
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>AI Fever Dream + AI Mood Mirror (LTX-2)</h1>
      <p>Generate looping LTX-2 videos from prompts or mirror your live mood from the webcam.</p>
    </header>
    <main>
      <section class="panel">
        <label for="mode">Mode</label>
        <select id="mode">
          <option value="fever">AI Fever Dream</option>
          <option value="mood">AI Mood Mirror</option>
          <option value="v2v">Video-to-Video (IC-LoRA)</option>
        </select>

        <label for="prompt">Prompt</label>
        <textarea id="prompt"></textarea>

        <label for="negativePrompt">Negative prompt</label>
        <textarea id="negativePrompt" placeholder="e.g., people, faces, text, watermark"></textarea>

        <label for="resolution">Generation resolution</label>
        <select id="resolution">
          <option value="1280x736">1280 × 736 (native max)</option>
          <option value="1024x576">1024 × 576</option>
          <option value="960x544">960 × 544</option>
          <option value="640x384">640 × 384</option>
        </select>

        <label for="outputResolution">Output resolution</label>
        <select id="outputResolution">
          <option value="none">No upscaling</option>
          <option value="1920x1088">1920 × 1088 (1080p-ish)</option>
          <option value="3840x2176">3840 × 2176 (4K-ish)</option>
        </select>

        <div id="dreamControls">
          <div class="row" style="display: none;">
            <div>
              <label for="width">Width</label>
              <input id="width" type="number" min="256" step="32" disabled />
            </div>
            <div>
              <label for="height">Height</label>
              <input id="height" type="number" min="256" step="32" disabled />
            </div>
          </div>

          <label for="seed">Seed (optional)</label>
          <input id="seed" type="number" placeholder="Leave empty for random" />

          <label for="dreamStrength">Dream strength</label>
          <input id="dreamStrength" type="range" min="0" max="1" step="0.05" />

          <label for="motion">Motion</label>
          <input id="motion" type="range" min="0" max="1" step="0.05" />

          <div id="moodControls">
            <label for="basePrompt">Mood Mirror base prompt</label>
            <textarea id="basePrompt"></textarea>

            <label for="identityStrength">Retain identity → Abstract mirror</label>
            <input id="identityStrength" type="range" min="0" max="1" step="0.05" />

            <button id="webcamToggle" type="button">Enable webcam</button>
            <div class="mood-values" id="moodValues">Mood: waiting for camera…</div>
          </div>

          <div class="row">
            <button id="startButton" type="button">Start dreaming</button>
            <button id="applyButton" type="button">Update dream</button>
            <button id="stopButton" type="button">Stop dreaming</button>
          </div>
          <div class="status" id="status"></div>
        </div>
      </section>

      <section class="panel" id="streamsPanel">
        <h3 id="streamsHeading">Streams</h3>
        <div class="grid" id="streamGrid"></div>
      </section>

      <section class="panel" id="v2vPanel">
        <h3>Video-to-Video (IC-LoRA)</h3>
        <button id="v2vUpload" type="button">Upload Video</button>
        <input id="v2vFile" type="file" accept="video/*" style="display: none;" />
        <div class="status">
          Uses the main prompt + negative prompt above. Fixed 24 fps. “Stitched” means multiple shorter
          generations are created and concatenated to reach longer durations.
        </div>
        <div class="row">
          <div>
            <label for="v2vStrength">Dreaming</label>
            <input id="v2vStrength" type="range" min="0" max="1" step="0.05" value="0.7" />
          </div>
          <div>
            <label for="v2vSeconds">Seconds</label>
            <select id="v2vSeconds">
              <option value="10">10</option>
              <option value="30">30</option>
              <option value="60">60</option>
              <option value="120">120</option>
              <option value="360">360</option>
            </select>
          </div>
        </div>
        <button id="v2vSubmit" type="button">Generate Video</button>
        <div class="status" id="v2vStatus"></div>
        <video id="v2vPreview" controls style="width: 100%; margin-top: 8px; display: none;"></video>
      </section>
    </main>

    <video id="webcamVideo" autoplay playsinline style="display: none;"></video>
    <canvas id="webcamCanvas" width="640" height="360" style="display: none;"></canvas>

    <script>
      const modeSelect = document.getElementById("mode");
      const promptInput = document.getElementById("prompt");
      const negativePromptInput = document.getElementById("negativePrompt");
      const resolutionSelect = document.getElementById("resolution");
      const outputResolutionSelect = document.getElementById("outputResolution");
      const dreamControls = document.getElementById("dreamControls");
      const widthInput = document.getElementById("width");
      const heightInput = document.getElementById("height");
      const seedInput = document.getElementById("seed");
      const dreamStrengthInput = document.getElementById("dreamStrength");
      const motionInput = document.getElementById("motion");
      const moodControls = document.getElementById("moodControls");
      const basePromptInput = document.getElementById("basePrompt");
      const identityStrengthInput = document.getElementById("identityStrength");
      const webcamToggle = document.getElementById("webcamToggle");
      const moodValues = document.getElementById("moodValues");
      const webcamVideo = document.getElementById("webcamVideo");
      const webcamCanvas = document.getElementById("webcamCanvas");
      const webcamCtx = webcamCanvas.getContext("2d");
      const applyButton = document.getElementById("applyButton");
      const startButton = document.getElementById("startButton");
      const stopButton = document.getElementById("stopButton");
      const status = document.getElementById("status");
      const streamsHeading = document.getElementById("streamsHeading");
      const streamGrid = document.getElementById("streamGrid");
      const streamsPanel = document.getElementById("streamsPanel");
      const v2vPanel = document.getElementById("v2vPanel");
      const v2vUpload = document.getElementById("v2vUpload");
      const v2vFile = document.getElementById("v2vFile");
      const v2vStrength = document.getElementById("v2vStrength");
      const v2vSeconds = document.getElementById("v2vSeconds");
      const v2vSubmit = document.getElementById("v2vSubmit");
      const v2vStatus = document.getElementById("v2vStatus");
      const v2vPreview = document.getElementById("v2vPreview");
      const V2V_FPS = 24;
      const v2vSecondsPresets = [10, 30, 60, 120, 360];
      const v2vMaxFrames = 257;
      const v2vTotalMaxFrames = 8640;
      let cachedConfig = null;
      let currentStreamsCount = 1;
      let webcamStream = null;
      let webcamInterval = null;

      function setStatus(message) {
        status.textContent = message;
      }

      function setV2vStatus(message) {
        v2vStatus.textContent = message;
      }

      function adjustV2vFrames(targetFrames) {
        const target = Math.max(1, Math.round(targetFrames || 1));
        const k = Math.round((target - 1) / 8);
        return Math.max(1, 1 + 8 * k);
      }

      function updateV2vSecondsOptions() {
        const fps = V2V_FPS;
        v2vSeconds.innerHTML = "";
        let firstEnabled = null;
        for (const seconds of v2vSecondsPresets) {
          const targetFrames = seconds * fps;
          const adjustedFrames = adjustV2vFrames(targetFrames);
          const actualSeconds = adjustedFrames / fps;
          const option = document.createElement("option");
          option.value = String(seconds);
          option.dataset.frames = String(adjustedFrames);
          option.dataset.actualSeconds = actualSeconds.toFixed(2);
          if (adjustedFrames > v2vTotalMaxFrames) {
            option.disabled = true;
            option.textContent = `${seconds}s (too long)`;
          } else if (adjustedFrames > v2vMaxFrames) {
            option.textContent = `${seconds}s (~${actualSeconds.toFixed(1)}s, stitched)`;
            if (!firstEnabled) {
              firstEnabled = option;
            }
          } else {
            option.textContent = `${seconds}s (~${actualSeconds.toFixed(1)}s)`;
            if (!firstEnabled) {
              firstEnabled = option;
            }
          }
          v2vSeconds.appendChild(option);
        }
        if (firstEnabled) {
          firstEnabled.selected = true;
        }
      }

      function updateMoodControls() {
        v2vPanel.style.display = modeSelect.value === "v2v" ? "block" : "none";
        const v2vActive = modeSelect.value === "v2v";
        startButton.disabled = v2vActive;
        applyButton.disabled = v2vActive;
        dreamControls.style.display = v2vActive ? "none" : "block";
        streamsPanel.style.display = v2vActive ? "none" : "block";
        streamsHeading.textContent = v2vActive ? "Video-to-Video Output" : "Streams";
        moodControls.style.display = modeSelect.value === "mood" ? "block" : "none";
      }

      function resolveOutputSettings() {
        if (outputResolutionSelect.value === "none") {
          return {
            output_mode: "native",
          };
        }
        return {
          output_mode: "upscaled",
        };
      }

      function applyOutputResolutionToMode() {
        if (outputResolutionSelect.value === "none") {
          resolutionSelect.disabled = false;
          const [w, h] = resolutionSelect.value.split("x").map((v) => parseInt(v, 10));
          if (!Number.isNaN(w) && !Number.isNaN(h)) {
            widthInput.value = w;
            heightInput.value = h;
          }
          return;
        }
        resolutionSelect.disabled = true;
        const [ow, oh] = outputResolutionSelect.value.split("x").map((v) => parseInt(v, 10));
        if (!Number.isNaN(ow) && !Number.isNaN(oh)) {
          widthInput.value = ow;
          heightInput.value = oh;
        }
      }

      function buildConfig() {
        const outputSettings = resolveOutputSettings();
        const fallback = cachedConfig || {};
        return {
          mode: modeSelect.value,
          prompt: promptInput.value.trim(),
          negative_prompt: negativePromptInput.value.trim(),
          width: parseInt(widthInput.value, 10),
          height: parseInt(heightInput.value, 10),
          fps: fallback.fps ?? 24,
          streams: fallback.streams ?? 1,
          output_mode: outputSettings.output_mode,
          seed: seedInput.value ? parseInt(seedInput.value, 10) : null,
          dream_strength: parseFloat(dreamStrengthInput.value),
          motion: parseFloat(motionInput.value),
          base_prompt: basePromptInput.value.trim() || fallback.base_prompt || "portrait, cinematic lighting",
          identity_strength: parseFloat(identityStrengthInput.value || String(fallback.identity_strength ?? 0.7)),
          audio_enabled: false,
        };
      }

      async function applyConfig({ start = false } = {}) {
        if (modeSelect.value === "v2v") {
          setStatus("V2V uses the panel below. Start/Update are disabled in V2V mode.");
          return;
        }
        setStatus(start ? "Starting dream..." : "Updating dream...");
        const config = buildConfig();
        const response = await fetch("/api/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(config),
        });
        if (!response.ok) {
          const data = await response.json();
          setStatus(`Error: ${data.detail}`);
          return;
        }
        const updated = await response.json();
        if (start) {
          await fetch("/api/start", { method: "POST" });
        }
        setStatus(start ? "Dream started." : "Dream updated.");
        if (updated.streams !== currentStreamsCount) {
          currentStreamsCount = updated.streams;
          buildStreams(updated.streams);
        }
      }

      function buildStreams(count) {
        streamGrid.innerHTML = "";
        const columns = count <= 1 ? 1 : 2;
        streamGrid.style.gridTemplateColumns = `repeat(${columns}, minmax(0, 1fr))`;
        for (let i = 0; i < count; i++) {
          const wrapper = document.createElement("div");
          wrapper.className = "stream";
          const img = document.createElement("img");
          img.src = `/stream/${i}.mjpg?ts=${Date.now()}`;
          wrapper.appendChild(img);
          streamGrid.appendChild(wrapper);
        }
      }

      function handleV2vFile(file) {
        if (!file) {
          return;
        }
        const dt = new DataTransfer();
        dt.items.add(file);
        v2vFile.files = dt.files;
        setV2vStatus(`Selected: ${file.name}`);
      }

      async function submitV2v() {
        const file = v2vFile.files[0];
        if (!file) {
          setV2vStatus("Please select a video file.");
          return;
        }
        if (!promptInput.value.trim()) {
          setV2vStatus("Please enter a prompt.");
          return;
        }
        const fps = V2V_FPS;
        const seconds = parseFloat(v2vSeconds.value || "0");
        const targetFrames = seconds * fps;
        const adjustedFrames = adjustV2vFrames(targetFrames);
        const actualSeconds = adjustedFrames / fps;
        setV2vStatus(`Generating ~${actualSeconds.toFixed(1)}s (${adjustedFrames} frames @ ${fps} fps)...`);
        const form = new FormData();
        form.append("file", file);
        form.append("prompt", promptInput.value.trim());
        form.append("negative_prompt", negativePromptInput.value.trim());
        form.append("strength", String(v2vStrength.value || "0.7"));
        form.append("seconds", String(seconds || "0"));
        form.append("num_frames", String(adjustedFrames));
        form.append("fps", String(fps));
        try {
          const response = await fetch("/api/v2v", { method: "POST", body: form });
          if (!response.ok) {
            const data = await response.json();
            setV2vStatus(`Error: ${data.detail || "request failed"}`);
            return;
          }
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          v2vPreview.src = url;
          v2vPreview.style.display = "block";
          setV2vStatus("Done.");
        } catch (err) {
          setV2vStatus(`Error: ${err}`);
        }
      }

      async function stopInference() {
        setStatus("Stopping dream...");
        try {
          const response = await fetch("/api/stop", { method: "POST" });
          if (!response.ok) {
            const data = await response.json();
            setStatus(`Error: ${data.detail || "stop failed"}`);
            return;
          }
          setStatus("Dream stopped.");
        } catch (err) {
          setStatus(`Error: ${err}`);
        }
      }

      async function sendMoodFrame() {
        if (!webcamStream) {
          return;
        }
        webcamCanvas.width = webcamVideo.videoWidth || 640;
        webcamCanvas.height = webcamVideo.videoHeight || 360;
        webcamCtx.drawImage(webcamVideo, 0, 0, webcamCanvas.width, webcamCanvas.height);
        const blob = await new Promise((resolve) => webcamCanvas.toBlob(resolve, "image/jpeg", 0.7));
        if (!blob) return;
        const response = await fetch("/api/mood/frame", { method: "POST", body: blob });
        if (response.ok) {
          const mood = await response.json();
          moodValues.textContent = `Mood: valence ${mood.valence.toFixed(2)} | arousal ${mood.arousal.toFixed(2)} | ${
            mood.labels.join(", ") || "neutral"
          }`;
        }
      }

      async function toggleWebcam() {
        if (webcamStream) {
          webcamStream.getTracks().forEach((track) => track.stop());
          webcamStream = null;
          clearInterval(webcamInterval);
          webcamInterval = null;
          webcamToggle.textContent = "Enable webcam";
          moodValues.textContent = "Mood: webcam disabled.";
          return;
        }
        try {
          webcamStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          webcamVideo.srcObject = webcamStream;
          webcamToggle.textContent = "Disable webcam";
          webcamInterval = setInterval(sendMoodFrame, 200);
        } catch (error) {
          moodValues.textContent = `Webcam error: ${error}`;
        }
      }

      async function loadConfig() {
        const response = await fetch("/api/config");
        const config = await response.json();
        cachedConfig = config;
        modeSelect.value = config.mode;
        promptInput.value = config.prompt;
        negativePromptInput.value = config.negative_prompt || "";
        widthInput.value = config.width;
        heightInput.value = config.height;
        const presetValue = `${config.width}x${config.height}`;
        const hasPreset = Array.from(resolutionSelect.options).some((opt) => opt.value === presetValue);
        if (config.output_mode === "upscaled") {
          outputResolutionSelect.value = hasPreset ? presetValue : "3840x2176";
        } else {
          outputResolutionSelect.value = "none";
          resolutionSelect.value = hasPreset ? presetValue : resolutionSelect.options[0]?.value || presetValue;
        }
        applyOutputResolutionToMode();
        seedInput.value = config.seed ?? "";
        dreamStrengthInput.value = config.dream_strength;
        motionInput.value = config.motion;
        basePromptInput.value = config.base_prompt || "portrait, cinematic lighting";
        identityStrengthInput.value = config.identity_strength ?? 0.7;
        updateMoodControls();
        updateV2vSecondsOptions();
        currentStreamsCount = config.streams;
        buildStreams(config.streams);
      }

      modeSelect.addEventListener("change", updateMoodControls);
      startButton.addEventListener("click", () => applyConfig({ start: true }));
      applyButton.addEventListener("click", () => applyConfig({ start: false }));
      stopButton.addEventListener("click", stopInference);
      resolutionSelect.addEventListener("change", () => {
        const [w, h] = resolutionSelect.value.split("x").map((v) => parseInt(v, 10));
        if (!Number.isNaN(w) && !Number.isNaN(h)) {
          widthInput.value = w;
          heightInput.value = h;
        }
      });
      outputResolutionSelect.addEventListener("change", applyOutputResolutionToMode);
      webcamToggle.addEventListener("click", toggleWebcam);
      v2vUpload.addEventListener("click", () => v2vFile.click());
      v2vFile.addEventListener("change", () => handleV2vFile(v2vFile.files[0]));
      v2vSubmit.addEventListener("click", submitV2v);

      loadConfig();
      applyOutputResolutionToMode();
    </script>
  </body>
</html>
