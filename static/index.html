<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Continuity Studio + Mood Mirror</title>
    <style>
      body {
        font-family: "Inter", "Segoe UI", sans-serif;
        background: #0b0d14;
        color: #e6e9f2;
        margin: 0;
        padding: 0;
      }
      header {
        padding: 24px 32px;
        background: #131826;
        border-bottom: 1px solid #1f2636;
      }
      main {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 24px;
        padding: 24px 32px;
      }
      .left-column,
      .right-column {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }
      .panel {
        background: #121522;
        border-radius: 12px;
        padding: 16px;
        border: 1px solid #1f2636;
      }
      label {
        display: block;
        font-size: 0.85rem;
        margin-top: 12px;
        margin-bottom: 4px;
        color: #b8c0d8;
      }
      input,
      textarea,
      select,
      button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #2b3247;
        background: #0d111c;
        color: #e6e9f2;
      }
      textarea {
        min-height: 70px;
      }
      button {
        background: #4b7bff;
        border: none;
        font-weight: 600;
        cursor: pointer;
      }
      button:hover {
        background: #3b6af0;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 16px;
      }
      .stream {
        background: #0d111c;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid #20263b;
      }
      .stream img {
        width: 100%;
        display: block;
      }
      .stream video {
        width: 100%;
        display: block;
      }
      .chunk-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 8px;
        margin-top: 12px;
      }
      .chunk-grid video {
        width: 100%;
        display: block;
        border-radius: 6px;
        border: 1px solid #20263b;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .status {
        margin-top: 12px;
        font-size: 0.85rem;
        color: #9aa4bf;
      }
      .mood-values {
        font-size: 0.85rem;
        margin-top: 6px;
      }
      .toggle-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 12px;
        color: #b8c0d8;
        font-size: 0.85rem;
      }
      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .control-row input[type="number"],
      .control-row input[type="text"],
      .control-row select {
        max-width: 140px;
      }
      .settings-item {
        margin-top: 12px;
      }
      .settings-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .sigma-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        gap: 8px;
        margin-top: 8px;
      }
      .settings-item label {
        margin-top: 0;
      }
      input[type="checkbox"] {
        width: auto;
        padding: 0;
        background: transparent;
        border: none;
      }
      details.advanced {
        background: #0d111c;
        border-radius: 10px;
        border: 1px solid #20263b;
        padding: 0;
      }
      details.advanced summary {
        cursor: pointer;
        padding: 12px 14px;
        font-weight: 600;
        color: #d6dbec;
        list-style: none;
      }
      details.advanced summary::-webkit-details-marker {
        display: none;
      }
      details.advanced summary::after {
        content: "▾";
        float: right;
        color: #9aa4bf;
      }
      details.advanced[open] summary::after {
        content: "▴";
      }
      .advanced-body {
        padding: 12px 14px 14px;
        border-top: 1px solid #20263b;
        max-height: 360px;
        overflow: auto;
      }
      .advanced-body .row {
        margin-top: 12px;
      }
      .progress-wrap {
        margin-top: 12px;
      }
      .progress-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.8rem;
        color: #9aa4bf;
        margin-bottom: 6px;
      }
      .progress-bar {
        width: 100%;
        height: 8px;
        background: #20263b;
        border-radius: 999px;
        overflow: hidden;
      }
      .progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4b7bff, #7ba2ff);
        transition: width 0.25s ease;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Continuity Studio (LTX-2)</h1>
      <p>Generate continuous LTX-2 video streams or mirror live mood signals from your webcam.</p>
    </header>
    <main>
      <div class="left-column">
        <section class="panel">
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="fever">Continuity Studio</option>
            <option value="commercial_lock">Commercial Mode (60s Lock)</option>
            <option value="mood">AI Mood Mirror</option>
            <option value="v2v">Video-to-Video (IC-LoRA)</option>
          </select>

          <label for="prompt">Prompt</label>
          <textarea id="prompt"></textarea>

          <label for="negativePrompt">Negative prompt</label>
          <textarea id="negativePrompt" placeholder="e.g., people, faces, text, watermark"></textarea>

          <label for="resolution">Generation resolution</label>
          <select id="resolution">
            <option value="1280x736">1280 × 736 (native max)</option>
            <option value="1024x576">1024 × 576</option>
            <option value="960x544">960 × 544</option>
            <option value="640x384">640 × 384</option>
          </select>

          <label for="outputResolution">Output resolution</label>
          <select id="outputResolution">
            <option value="none">No upscaling</option>
            <option value="1920x1088">1920 × 1088 (1080p-ish)</option>
            <option value="3840x2176">3840 × 2176 (4K-ish)</option>
          </select>

          <div id="dreamControls">
            <div class="row" style="display: none;">
              <div>
                <label for="width">Width</label>
                <input id="width" type="number" min="256" step="32" disabled />
              </div>
              <div>
                <label for="height">Height</label>
                <input id="height" type="number" min="256" step="32" disabled />
              </div>
            </div>

            <label for="seed">Seed (optional)</label>
            <input id="seed" type="number" placeholder="Leave empty for random" />

            <label class="control-row" for="dreamStrength">
              <span>Dream strength</span>
            <input id="dreamStrength" type="number" min="0" max="1" step="0.01" value="0.15" />
            </label>

            <label class="control-row" for="motion">
              <span>Motion</span>
            <input id="motion" type="number" min="0" max="1" step="0.01" value="0.4" />
            </label>

            <label class="control-row" for="promptStrength">
              <span>Prompt Strength</span>
            <input id="promptStrength" type="number" min="0.8" max="2" step="0.01" value="1.0" />
            </label>

            <label class="control-row" for="qualitySteps">
              <span>Steps</span>
              <input id="qualitySteps" type="number" min="4" max="24" step="1" value="8" />
            </label>

            <label class="toggle-row">
              <input id="qualityLock" type="checkbox" />
              Quality Lock
            </label>

            <div id="qualityLockControls" style="display: none;">
              <label class="control-row" for="qualityLockStrength">
                <span>Lock Strength</span>
                <input id="qualityLockStrength" type="number" min="0.1" max="0.7" step="0.01" value="0.35" />
              </label>

              <label class="control-row" for="qualityLockFrames">
                <span>Anchor Frames</span>
                <input id="qualityLockFrames" type="number" min="1" max="6" step="1" value="3" />
              </label>

              <label class="control-row" for="dropPrefixFrames">
                <span>Drop Prefix Frames</span>
                <input id="dropPrefixFrames" type="number" min="0" max="4" step="1" value="0" />
              </label>
            </div>

            <label class="toggle-row">
              <input id="promptDrift" type="checkbox" />
              Prompt Drift
            </label>

            <div id="moodControls">
              <label for="basePrompt">Mood Mirror base prompt</label>
              <textarea id="basePrompt"></textarea>

              <label class="control-row" for="identityStrength">
                <span>Retain identity → Abstract mirror</span>
                <input id="identityStrength" type="number" min="0" max="1" step="0.01" value="0.7" />
              </label>

              <button id="webcamToggle" type="button">Enable webcam</button>
              <div class="mood-values" id="moodValues">Mood: waiting for camera…</div>
            </div>

            <div class="row">
              <button id="startButton" type="button">Start dreaming</button>
              <button id="applyButton" type="button">Update dream</button>
              <button id="stopButton" type="button">Stop dreaming</button>
            </div>
            <div class="row" id="commercialControls" style="display: none;">
              <button id="commercialGenerate" type="button">Generate Video</button>
              <button id="commercialStop" type="button">Stop Generation</button>
            </div>
            <div class="progress-wrap" id="commercialProgress" style="display: none;">
              <div class="progress-label">
                <span>Generation Progress</span>
                <span id="commercialProgressText">0%</span>
              </div>
              <div class="progress-bar">
                <div class="progress-fill" id="commercialProgressFill"></div>
              </div>
            </div>
            <div class="status" id="status"></div>
          </div>
        </section>

        <section class="panel" id="settingsPanel">
          <details class="advanced">
            <summary>Advanced Settings</summary>
            <div class="advanced-body">
              <div class="status" id="settingsStatus"></div>
              <div id="settingsList"></div>
              <div class="row">
                <button id="settingsApply" type="button">Apply settings</button>
                <button id="settingsReset" type="button">Reset defaults</button>
              </div>
            </div>
          </details>
        </section>
      </div>

      <div class="right-column">
        <section class="panel" id="streamsPanel">
          <h3 id="streamsHeading">Streams</h3>
          <div class="grid" id="streamGrid"></div>
        </section>

        <section class="panel" id="audioPanel">
          <h3>Audio</h3>
          <label for="audioStream">Audio stream</label>
          <select id="audioStream"></select>
          <button id="audioToggle" type="button">Enable audio</button>
          <div class="status" id="audioStatus"></div>
          <audio id="audioPlayer" controls style="width: 100%; margin-top: 8px; display: none;"></audio>
        </section>

        <section class="panel" id="v2vPanel">
          <h3>Video-to-Video (IC-LoRA)</h3>
          <button id="v2vUpload" type="button">Upload Video</button>
          <input id="v2vFile" type="file" accept="video/*" style="display: none;" />
          <div class="status">
            Uses the main prompt + negative prompt above. Fixed 24 fps. “Stitched” means multiple shorter
            generations are created and concatenated to reach longer durations.
          </div>
          <div class="row">
            <div>
              <label class="control-row" for="v2vStrength">
                <span>Dreaming</span>
                <input id="v2vStrength" type="number" min="0" max="1" step="0.01" value="0.7" />
              </label>
            </div>
            <div>
              <label for="v2vSeconds">Seconds</label>
              <select id="v2vSeconds">
                <option value="10">10</option>
                <option value="30">30</option>
                <option value="60">60</option>
                <option value="120">120</option>
                <option value="360">360</option>
              </select>
            </div>
          </div>
          <button id="v2vSubmit" type="button">Generate Video</button>
          <div class="status" id="v2vStatus"></div>
          <video id="v2vPreview" controls style="width: 100%; margin-top: 8px; display: none;"></video>
        </section>
      </div>
    </main>

    <video id="webcamVideo" autoplay playsinline style="display: none;"></video>
    <canvas id="webcamCanvas" width="640" height="360" style="display: none;"></canvas>

    <script>
      const modeSelect = document.getElementById("mode");
      const promptInput = document.getElementById("prompt");
      const negativePromptInput = document.getElementById("negativePrompt");
      const resolutionSelect = document.getElementById("resolution");
      const outputResolutionSelect = document.getElementById("outputResolution");
      const dreamControls = document.getElementById("dreamControls");
      const widthInput = document.getElementById("width");
      const heightInput = document.getElementById("height");
      const seedInput = document.getElementById("seed");
      const dreamStrengthInput = document.getElementById("dreamStrength");
      const motionInput = document.getElementById("motion");
      const promptStrengthInput = document.getElementById("promptStrength");
      const qualityStepsInput = document.getElementById("qualitySteps");
      const qualityLockToggle = document.getElementById("qualityLock");
      const qualityLockControls = document.getElementById("qualityLockControls");
      const qualityLockStrengthInput = document.getElementById("qualityLockStrength");
      const qualityLockFramesInput = document.getElementById("qualityLockFrames");
      const dropPrefixFramesInput = document.getElementById("dropPrefixFrames");
      const promptDriftToggle = document.getElementById("promptDrift");
      const moodControls = document.getElementById("moodControls");
      const basePromptInput = document.getElementById("basePrompt");
      const identityStrengthInput = document.getElementById("identityStrength");
      const webcamToggle = document.getElementById("webcamToggle");
      const moodValues = document.getElementById("moodValues");
      const webcamVideo = document.getElementById("webcamVideo");
      const webcamCanvas = document.getElementById("webcamCanvas");
      const webcamCtx = webcamCanvas.getContext("2d");
      const applyButton = document.getElementById("applyButton");
      const startButton = document.getElementById("startButton");
      const stopButton = document.getElementById("stopButton");
      const status = document.getElementById("status");
      const streamsHeading = document.getElementById("streamsHeading");
      const streamGrid = document.getElementById("streamGrid");
      const streamsPanel = document.getElementById("streamsPanel");
      const v2vPanel = document.getElementById("v2vPanel");
      const audioPanel = document.getElementById("audioPanel");
      const audioToggle = document.getElementById("audioToggle");
      const audioStatus = document.getElementById("audioStatus");
      const audioPlayer = document.getElementById("audioPlayer");
      const audioStreamSelect = document.getElementById("audioStream");
      const settingsPanel = document.getElementById("settingsPanel");
      const settingsList = document.getElementById("settingsList");
      const settingsStatus = document.getElementById("settingsStatus");
      const settingsApply = document.getElementById("settingsApply");
      const settingsReset = document.getElementById("settingsReset");
      const v2vUpload = document.getElementById("v2vUpload");
      const v2vFile = document.getElementById("v2vFile");
      const v2vStrength = document.getElementById("v2vStrength");
      const v2vSeconds = document.getElementById("v2vSeconds");
      const v2vSubmit = document.getElementById("v2vSubmit");
      const v2vStatus = document.getElementById("v2vStatus");
      const v2vPreview = document.getElementById("v2vPreview");
      const commercialControls = document.getElementById("commercialControls");
      const commercialGenerate = document.getElementById("commercialGenerate");
      const commercialStop = document.getElementById("commercialStop");
      const commercialProgress = document.getElementById("commercialProgress");
      const commercialProgressText = document.getElementById("commercialProgressText");
      const commercialProgressFill = document.getElementById("commercialProgressFill");
      const V2V_FPS = 24;
      const v2vSecondsPresets = [10, 30, 60, 120, 360];
      const v2vMaxFrames = 257;
      const v2vTotalMaxFrames = 8640;
      let cachedConfig = null;
      let currentStreamsCount = 1;
      let webcamStream = null;
      let webcamInterval = null;
      let audioEnabled = false;
      let audioInterval = null;
      let lastAudioTs = 0;
      let commercialInterval = null;
      let commercialLastUpdated = [];
      let commercialChunksLoaded = [];

      function setStatus(message) {
        status.textContent = message;
      }

      function setAudioStatus(message) {
        audioStatus.textContent = message;
      }

      function setSettingsStatus(message) {
        settingsStatus.textContent = message;
      }

      function setV2vStatus(message) {
        v2vStatus.textContent = message;
      }

      function adjustV2vFrames(targetFrames) {
        const target = Math.max(1, Math.round(targetFrames || 1));
        const k = Math.round((target - 1) / 8);
        return Math.max(1, 1 + 8 * k);
      }

      function updateV2vSecondsOptions() {
        const fps = V2V_FPS;
        v2vSeconds.innerHTML = "";
        let firstEnabled = null;
        for (const seconds of v2vSecondsPresets) {
          const targetFrames = seconds * fps;
          const adjustedFrames = adjustV2vFrames(targetFrames);
          const actualSeconds = adjustedFrames / fps;
          const option = document.createElement("option");
          option.value = String(seconds);
          option.dataset.frames = String(adjustedFrames);
          option.dataset.actualSeconds = actualSeconds.toFixed(2);
          if (adjustedFrames > v2vTotalMaxFrames) {
            option.disabled = true;
            option.textContent = `${seconds}s (too long)`;
          } else if (adjustedFrames > v2vMaxFrames) {
            option.textContent = `${seconds}s (~${actualSeconds.toFixed(1)}s, stitched)`;
            if (!firstEnabled) {
              firstEnabled = option;
            }
          } else {
            option.textContent = `${seconds}s (~${actualSeconds.toFixed(1)}s)`;
            if (!firstEnabled) {
              firstEnabled = option;
            }
          }
          v2vSeconds.appendChild(option);
        }
        if (firstEnabled) {
          firstEnabled.selected = true;
        }
      }

      function updateMoodControls() {
        v2vPanel.style.display = modeSelect.value === "v2v" ? "block" : "none";
        const v2vActive = modeSelect.value === "v2v";
        startButton.disabled = v2vActive;
        applyButton.disabled = v2vActive;
        dreamControls.style.display = v2vActive ? "none" : "block";
        streamsPanel.style.display = v2vActive ? "none" : "block";
        streamsHeading.textContent = v2vActive ? "Video-to-Video Output" : "Streams";
        moodControls.style.display = modeSelect.value === "mood" ? "block" : "none";
        audioPanel.style.display = v2vActive ? "none" : "block";
        const commercialActive = modeSelect.value === "commercial_lock";
        commercialControls.style.display = commercialActive ? "block" : "none";
        commercialProgress.style.display = commercialActive ? "block" : "none";
        startButton.style.display = commercialActive ? "none" : "block";
        applyButton.style.display = commercialActive ? "none" : "block";
        stopButton.style.display = commercialActive ? "none" : "block";
        if (commercialActive) {
          promptDriftToggle.checked = false;
        }
        promptDriftToggle.disabled = commercialActive ? true : qualityLockToggle.checked;
        if (commercialActive) {
          startCommercialRefresh();
        } else {
          stopCommercialRefresh();
        }
        buildStreams(currentStreamsCount);
      }

      function updateQualityControls() {
        const enabled = qualityLockToggle.checked;
        qualityLockControls.style.display = enabled ? "block" : "none";
        const commercialActive = modeSelect.value === "commercial_lock";
        if (commercialActive) {
          promptDriftToggle.checked = false;
          promptDriftToggle.disabled = true;
          return;
        }
        if (enabled) {
          promptDriftToggle.checked = false;
          promptDriftToggle.disabled = true;
        } else {
          promptDriftToggle.disabled = false;
        }
      }

      function inferSettingRange(key, value) {
        const upper = key.toUpperCase();
        const numeric = Number(value);
        const isNumeric = !Number.isNaN(numeric);
        const presets = {
          LTX2_COMFY_PRESET: { min: 0, max: 1, step: 1 },
          LTX2_STAGE1_STEPS: { min: 1, max: 80, step: 1 },
          LTX2_STAGE1_CFG: { min: 0, max: 8, step: 0.01 },
          LTX2_SCHED_MAX_SHIFT: { min: 0, max: 4, step: 0.01 },
          LTX2_SCHED_BASE_SHIFT: { min: 0, max: 2, step: 0.01 },
          LTX2_SCHED_TERMINAL: { min: 0, max: 1, step: 0.01 },
          LTX2_SCHED_STRETCH: { min: 0, max: 4, step: 0.01 },
          LTX2_STAGE2_ENABLE: { min: 0, max: 1, step: 1 },
          LTX2_STAGE2_CFG: { min: 0, max: 4, step: 0.01 },
          LTX2_VAE_DECODE_TILED: { min: 0, max: 1, step: 1 },
          LTX2_VAE_TILE_SIZE: { min: 64, max: 2048, step: 64 },
          LTX2_VAE_OVERLAP: { min: 0, max: 256, step: 8 },
          LTX2_VAE_TEMPORAL_SIZE: { min: 64, max: 8192, step: 64 },
          LTX2_VAE_TEMPORAL_OVERLAP: { min: 0, max: 64, step: 1 },
        };
        if (presets[upper]) {
          const preset = presets[upper];
          const valueNum = Number.isNaN(numeric) ? preset.value ?? 0 : numeric;
          return { ...preset, value: valueNum };
        }
        const boolHints = ["ENABLE", "DISABLE", "SKIP", "PERSIST", "USE_", "AUTOSTART", "CHAINING", "DROP_", "PROMPT_DRIFT"];
        if (boolHints.some((hint) => upper.includes(hint)) && (value === "0" || value === "1")) {
          return { min: 0, max: 1, step: 1, value: Number(value) };
        }
        if (!isNumeric) {
          return { min: 0, max: 1, step: 1, value: 0 };
        }
        if (upper.includes("WIDTH") || upper.includes("HEIGHT")) {
          return { min: 64, max: 8192, step: 32, value: numeric };
        }
        if (upper.includes("FPS")) {
          return { min: 1, max: 60, step: 1, value: numeric };
        }
        if (upper.includes("SECONDS")) {
          const max = Math.max(10, Math.ceil(numeric * 2));
          return { min: 0, max, step: 0.1, value: numeric };
        }
        if (upper.includes("FRAMES")) {
          const max = Math.max(16, Math.ceil(numeric * 2));
          return { min: 0, max, step: 1, value: numeric };
        }
        if (upper.includes("STEPS")) {
          return { min: 0, max: 200, step: 1, value: numeric };
        }
        if (upper.includes("CFG")) {
          return { min: 0, max: 2, step: 0.01, value: numeric };
        }
        if (upper.includes("STRENGTH")) {
          const max = numeric > 1 ? 2 : 1;
          return { min: 0, max, step: 0.01, value: numeric };
        }
        if (Number.isInteger(numeric)) {
          const max = Math.max(10, Math.ceil(numeric * 2));
          return { min: 0, max, step: 1, value: numeric };
        }
        const max = Math.max(1, Math.ceil(numeric * 2));
        return { min: 0, max, step: 0.01, value: numeric };
      }

      function buildSettingsList(items) {
        settingsList.innerHTML = "";
        items.forEach((item) => {
          const wrapper = document.createElement("div");
          wrapper.className = "settings-item";
          const upper = item.key.toUpperCase();
          if (upper === "LTX2_SAMPLER_NAME") {
            const samplerOptions = ["euler_ancestral", "euler", "heun", "ddim", "dpmpp_2m", "dpmpp_2m_sde"];
            const row = document.createElement("label");
            row.className = "settings-row";
            row.htmlFor = `setting-${item.key}`;
            const labelText = document.createElement("span");
            labelText.textContent = item.key;
            const select = document.createElement("select");
            select.id = `setting-${item.key}`;
            select.dataset.key = item.key;
            select.dataset.options = samplerOptions.join("|");
            samplerOptions.forEach((opt) => {
              const option = document.createElement("option");
              option.value = opt;
              option.textContent = opt;
              select.appendChild(option);
            });
            select.value = samplerOptions.includes(item.value) ? item.value : samplerOptions[0];
            row.appendChild(labelText);
            row.appendChild(select);
            wrapper.appendChild(row);
            settingsList.appendChild(wrapper);
            return;
          }
          if (upper === "LTX2_STAGE2_MANUAL_SIGMAS") {
            const label = document.createElement("label");
            label.className = "settings-row";
            const labelText = document.createElement("span");
            labelText.textContent = item.key;
            label.appendChild(labelText);
            wrapper.appendChild(label);
            const raw = (item.value || "").trim();
            const parsed = raw
              ? raw.split(",").map((v) => parseFloat(v.trim())).filter((v) => !Number.isNaN(v))
              : [];
            const sigmas = parsed.length ? parsed : [0.909375, 0.725, 0.421875, 0.0];
            const grid = document.createElement("div");
            grid.className = "sigma-grid";
            sigmas.forEach((sigma, idx) => {
              const input = document.createElement("input");
              input.type = "number";
              input.dataset.key = item.key;
              input.dataset.sigmaIndex = String(idx);
              input.min = "0";
              input.max = "1";
              input.step = "0.01";
              input.value = String(Number.isFinite(sigma) ? sigma : 0);
              grid.appendChild(input);
            });
            wrapper.appendChild(grid);
            settingsList.appendChild(wrapper);
            return;
          }
          const range = inferSettingRange(item.key, item.value === "" ? "0" : item.value);
          const row = document.createElement("label");
          row.className = "settings-row";
          row.htmlFor = `setting-${item.key}`;
          const labelText = document.createElement("span");
          labelText.textContent = item.key;
          const input = document.createElement("input");
          const numeric = Number(item.value);
          if (!Number.isNaN(numeric) || item.value === "" || item.value === null) {
            input.type = "number";
            input.min = String(range.min);
            input.max = String(range.max);
            input.step = String(range.step);
            if (item.value === "") {
              input.value = "";
              input.placeholder = "empty";
            } else {
              input.value = String(range.value);
            }
          } else {
            input.type = "text";
            input.value = item.value || "";
          }
          input.id = `setting-${item.key}`;
          input.dataset.key = item.key;
          input.dataset.emptyAllowed = item.empty_allowed ? "1" : "0";
          row.appendChild(labelText);
          row.appendChild(input);
          wrapper.appendChild(row);
          settingsList.appendChild(wrapper);
        });
      }

      async function loadSettings() {
        try {
          const response = await fetch("/api/settings");
          if (!response.ok) {
            setSettingsStatus("Failed to load settings.");
            return;
          }
          const data = await response.json();
          buildSettingsList(data.settings || []);
          setSettingsStatus("");
        } catch (err) {
          setSettingsStatus(`Error: ${err}`);
        }
      }

      async function applySettings() {
        const updates = {};
        const selects = settingsList.querySelectorAll("select[data-key]");
        selects.forEach((select) => {
          const key = select.dataset.key;
          if (!key) return;
          updates[key] = select.value;
        });
        const inputs = settingsList.querySelectorAll("input[data-key]");
        const sigmaInputs = Array.from(inputs).filter((input) => input.dataset.key === "LTX2_STAGE2_MANUAL_SIGMAS");
        if (sigmaInputs.length) {
          const sigmas = sigmaInputs.map((input) => Number(input.value || 0).toFixed(6));
          updates["LTX2_STAGE2_MANUAL_SIGMAS"] = sigmas.join(",");
        }
        inputs.forEach((input) => {
          const key = input.dataset.key;
          if (!key || key === "LTX2_STAGE2_MANUAL_SIGMAS") return;
          const emptyAllowed = input.dataset.emptyAllowed === "1";
          if (emptyAllowed && input.value === "") {
            updates[key] = "";
            return;
          }
          updates[key] = input.value;
        });
        setSettingsStatus("Applying settings...");
        try {
          const response = await fetch("/api/settings", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ settings: updates }),
          });
          if (!response.ok) {
            const data = await response.json();
            setSettingsStatus(`Error: ${data.detail || "update failed"}`);
            return;
          }
          setSettingsStatus("Settings applied.");
        } catch (err) {
          setSettingsStatus(`Error: ${err}`);
        }
      }

      async function resetSettings() {
        setSettingsStatus("Resetting defaults...");
        try {
          const response = await fetch("/api/settings/reset", { method: "POST" });
          if (!response.ok) {
            const data = await response.json();
            setSettingsStatus(`Error: ${data.detail || "reset failed"}`);
            return;
          }
          await loadSettings();
          setSettingsStatus("Defaults restored.");
        } catch (err) {
          setSettingsStatus(`Error: ${err}`);
        }
      }

      function resolveOutputSettings() {
        if (outputResolutionSelect.value === "none") {
          return {
            output_mode: "native",
          };
        }
        return {
          output_mode: "upscaled",
        };
      }

      function applyOutputResolutionToMode() {
        if (outputResolutionSelect.value === "none") {
          resolutionSelect.disabled = false;
          const [w, h] = resolutionSelect.value.split("x").map((v) => parseInt(v, 10));
          if (!Number.isNaN(w) && !Number.isNaN(h)) {
            widthInput.value = w;
            heightInput.value = h;
          }
          return;
        }
        resolutionSelect.disabled = true;
        const [ow, oh] = outputResolutionSelect.value.split("x").map((v) => parseInt(v, 10));
        if (!Number.isNaN(ow) && !Number.isNaN(oh)) {
          widthInput.value = ow;
          heightInput.value = oh;
        }
      }

      function buildConfig() {
        const outputSettings = resolveOutputSettings();
        const fallback = cachedConfig || {};
        return {
          mode: modeSelect.value,
          generation_mode: modeSelect.value,
          prompt: promptInput.value.trim(),
          negative_prompt: negativePromptInput.value.trim(),
          width: parseInt(widthInput.value, 10),
          height: parseInt(heightInput.value, 10),
          fps: fallback.fps ?? 24,
          streams: fallback.streams ?? 1,
          output_mode: outputSettings.output_mode,
          seed: seedInput.value ? parseInt(seedInput.value, 10) : null,
          dream_strength: parseFloat(dreamStrengthInput.value),
          motion: parseFloat(motionInput.value),
          prompt_strength: parseFloat(promptStrengthInput.value),
          quality_steps: parseInt(qualityStepsInput.value, 10),
          quality_lock: qualityLockToggle.checked,
          quality_lock_strength: parseFloat(qualityLockStrengthInput.value),
          quality_lock_frames: parseInt(qualityLockFramesInput.value, 10),
          drop_prefix_frames: parseInt(dropPrefixFramesInput.value, 10),
          prompt_drift: promptDriftToggle.checked,
          base_prompt: basePromptInput.value.trim() || fallback.base_prompt || "portrait, cinematic lighting",
          identity_strength: parseFloat(identityStrengthInput.value || String(fallback.identity_strength ?? 0.7)),
          audio_enabled: false,
        };
      }

      async function applyConfig({ start = false } = {}) {
        if (modeSelect.value === "v2v") {
          setStatus("V2V uses the panel below. Start/Update are disabled in V2V mode.");
          return;
        }
        setStatus(start ? "Starting dream..." : "Updating dream...");
        const config = buildConfig();
        const response = await fetch("/api/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(config),
        });
        if (!response.ok) {
          const data = await response.json();
          setStatus(`Error: ${data.detail}`);
          return;
        }
        const updated = await response.json();
        if (start) {
          await fetch("/api/start", { method: "POST" });
        }
        setStatus(start ? "Dream started." : "Dream updated.");
        if (updated.streams !== currentStreamsCount) {
          currentStreamsCount = updated.streams;
          buildStreams(updated.streams);
        }
      }

      function buildStreams(count) {
        streamGrid.innerHTML = "";
        const columns = count <= 1 ? 1 : 2;
        streamGrid.style.gridTemplateColumns = `repeat(${columns}, minmax(0, 1fr))`;
        for (let i = 0; i < count; i++) {
          const wrapper = document.createElement("div");
          wrapper.className = "stream";
          if (modeSelect.value === "commercial_lock") {
            const video = document.createElement("video");
            video.id = `commercial-video-${i}`;
            video.src = `/api/commercial/latest.mp4?stream=${i}&ts=${Date.now()}`;
            video.controls = true;
            video.autoplay = true;
            video.loop = false;
            video.playsInline = true;
            video.preload = "auto";
            video.style.width = "100%";
            wrapper.appendChild(video);
            const chunkGrid = document.createElement("div");
            chunkGrid.className = "chunk-grid";
            chunkGrid.id = `chunk-grid-${i}`;
            wrapper.appendChild(chunkGrid);
          } else {
            const img = document.createElement("img");
            img.src = `/stream/${i}.mjpg?ts=${Date.now()}`;
            wrapper.appendChild(img);
          }
          streamGrid.appendChild(wrapper);
        }
        buildAudioStreams(count);
      }

      async function refreshCommercialVideos() {
        if (modeSelect.value !== "commercial_lock") return;
        const videos = streamGrid.querySelectorAll("video");
        for (let i = 0; i < videos.length; i++) {
          const video = videos[i];
          try {
            const response = await fetch(`/api/commercial/status?stream=${i}`);
            if (!response.ok) continue;
            const data = await response.json();
            updateCommercialProgress(data);
            if (data.done && !commercialChunksLoaded[i]) {
              await loadCommercialChunks(i);
            }
            if (!data.available) continue;
            const lastUpdated = commercialLastUpdated[i] || 0;
            if (data.updated_at && data.updated_at <= lastUpdated) {
              if (data.done) {
                stopCommercialRefresh();
              }
              continue;
            }
            commercialLastUpdated[i] = data.updated_at || Date.now();
            video.src = `/api/commercial/latest.mp4?stream=${i}&ts=${Date.now()}`;
            video.load();
            video.currentTime = 0;
            video.loop = Boolean(data.done);
            await video.play();
            if (data.done) {
              stopCommercialRefresh();
            }
          } catch (_) {
            // ignore playback failures
          }
        }
      }

      function startCommercialRefresh() {
        if (commercialInterval) return;
        commercialInterval = setInterval(refreshCommercialVideos, 8000);
        refreshCommercialVideos();
      }

      function stopCommercialRefresh() {
        if (commercialInterval) {
          clearInterval(commercialInterval);
          commercialInterval = null;
        }
      }

      async function startCommercialGeneration() {
        if (modeSelect.value !== "commercial_lock") return;
        setStatus("Starting commercial render...");
        commercialLastUpdated = [];
        commercialChunksLoaded = [];
        setCommercialProgress(0);
        await applyConfig({ start: true });
        for (let i = 0; i < currentStreamsCount; i++) {
          const response = await fetch(`/api/commercial/start?stream=${i}`, { method: "POST" });
          if (!response.ok) {
            setStatus("Commercial start failed.");
            return;
          }
        }
        setStatus("Commercial render started.");
        startCommercialRefresh();
      }

      async function stopCommercialGeneration() {
        if (modeSelect.value !== "commercial_lock") return;
        setStatus("Stopping commercial render...");
        for (let i = 0; i < currentStreamsCount; i++) {
          await fetch(`/api/commercial/stop?stream=${i}`, { method: "POST" });
        }
        setStatus("Commercial render stopped.");
      }

      function setCommercialProgress(percent) {
        const clamped = Math.max(0, Math.min(100, percent));
        commercialProgressFill.style.width = `${clamped.toFixed(1)}%`;
        commercialProgressText.textContent = `${clamped.toFixed(0)}%`;
      }

      function updateCommercialProgress(data) {
        const total = Number(data.frames_total || 0);
        const done = Number(data.frames_done || 0);
        if (!total) {
          setCommercialProgress(0);
          return;
        }
        setCommercialProgress((done / total) * 100);
      }

      async function loadCommercialChunks(streamId) {
        try {
          const response = await fetch(`/api/commercial/chunks?stream=${streamId}`);
          if (!response.ok) return;
          const data = await response.json();
          const grid = document.getElementById(`chunk-grid-${streamId}`);
          if (!grid) return;
          grid.innerHTML = "";
          const chunks = data.chunks || [];
          chunks.forEach((chunkIdx) => {
            const clip = document.createElement("video");
            clip.src = `/api/commercial/chunk/${chunkIdx}.mp4?stream=${streamId}&ts=${Date.now()}`;
            clip.controls = true;
            clip.preload = "metadata";
            clip.playsInline = true;
            clip.muted = true;
            grid.appendChild(clip);
          });
          commercialChunksLoaded[streamId] = true;
        } catch (_) {
          // ignore chunk load errors
        }
      }

      function buildAudioStreams(count) {
        audioStreamSelect.innerHTML = "";
        for (let i = 0; i < count; i++) {
          const option = document.createElement("option");
          option.value = String(i);
          option.textContent = `Stream ${i + 1}`;
          audioStreamSelect.appendChild(option);
        }
      }

      function handleV2vFile(file) {
        if (!file) {
          return;
        }
        const dt = new DataTransfer();
        dt.items.add(file);
        v2vFile.files = dt.files;
        setV2vStatus(`Selected: ${file.name}`);
      }

      async function submitV2v() {
        const file = v2vFile.files[0];
        if (!file) {
          setV2vStatus("Please select a video file.");
          return;
        }
        if (!promptInput.value.trim()) {
          setV2vStatus("Please enter a prompt.");
          return;
        }
        const fps = V2V_FPS;
        const seconds = parseFloat(v2vSeconds.value || "0");
        const targetFrames = seconds * fps;
        const adjustedFrames = adjustV2vFrames(targetFrames);
        const actualSeconds = adjustedFrames / fps;
        setV2vStatus(`Generating ~${actualSeconds.toFixed(1)}s (${adjustedFrames} frames @ ${fps} fps)...`);
        const form = new FormData();
        form.append("file", file);
        form.append("prompt", promptInput.value.trim());
        form.append("negative_prompt", negativePromptInput.value.trim());
        form.append("strength", String(v2vStrength.value || "0.7"));
        form.append("seconds", String(seconds || "0"));
        form.append("num_frames", String(adjustedFrames));
        form.append("fps", String(fps));
        try {
          const response = await fetch("/api/v2v", { method: "POST", body: form });
          if (!response.ok) {
            const data = await response.json();
            setV2vStatus(`Error: ${data.detail || "request failed"}`);
            return;
          }
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          v2vPreview.src = url;
          v2vPreview.style.display = "block";
          setV2vStatus("Done.");
        } catch (err) {
          setV2vStatus(`Error: ${err}`);
        }
      }

      async function stopInference() {
        setStatus("Stopping dream...");
        try {
          const response = await fetch("/api/stop", { method: "POST" });
          if (!response.ok) {
            const data = await response.json();
            setStatus(`Error: ${data.detail || "stop failed"}`);
            return;
          }
          setStatus("Dream stopped.");
        } catch (err) {
          setStatus(`Error: ${err}`);
        }
      }

      async function pollAudioStatus() {
        if (!audioEnabled) return;
        if (modeSelect.value === "commercial_lock") return;
        const streamId = parseInt(audioStreamSelect.value || "0", 10) || 0;
        try {
          const response = await fetch(`/audio/status?stream=${streamId}`);
          if (!response.ok) {
            setAudioStatus("Audio status unavailable.");
            return;
          }
          const data = await response.json();
          if (!data.available) {
            setAudioStatus("No audio available yet.");
            return;
          }
          if (data.updated_at && data.updated_at > lastAudioTs) {
            lastAudioTs = data.updated_at;
            audioPlayer.src = `/audio/latest.wav?stream=${streamId}&ts=${Date.now()}`;
            audioPlayer.style.display = "block";
            await audioPlayer.play();
            setAudioStatus("Playing latest audio.");
          }
        } catch (err) {
          setAudioStatus(`Audio error: ${err}`);
        }
      }

      function startAudio() {
        if (audioEnabled) return;
        audioEnabled = true;
        audioToggle.textContent = "Disable audio";
        setAudioStatus("Audio enabled. Waiting for samples...");
        pollAudioStatus();
        audioInterval = setInterval(pollAudioStatus, 1000);
      }

      function stopAudio() {
        audioEnabled = false;
        audioToggle.textContent = "Enable audio";
        setAudioStatus("Audio disabled.");
        if (audioInterval) {
          clearInterval(audioInterval);
          audioInterval = null;
        }
        audioPlayer.pause();
      }

      async function sendMoodFrame() {
        if (!webcamStream) {
          return;
        }
        webcamCanvas.width = webcamVideo.videoWidth || 640;
        webcamCanvas.height = webcamVideo.videoHeight || 360;
        webcamCtx.drawImage(webcamVideo, 0, 0, webcamCanvas.width, webcamCanvas.height);
        const blob = await new Promise((resolve) => webcamCanvas.toBlob(resolve, "image/jpeg", 0.7));
        if (!blob) return;
        const response = await fetch("/api/mood/frame", { method: "POST", body: blob });
        if (response.ok) {
          const mood = await response.json();
          moodValues.textContent = `Mood: valence ${mood.valence.toFixed(2)} | arousal ${mood.arousal.toFixed(2)} | ${
            mood.labels.join(", ") || "neutral"
          }`;
        }
      }

      async function toggleWebcam() {
        if (webcamStream) {
          webcamStream.getTracks().forEach((track) => track.stop());
          webcamStream = null;
          clearInterval(webcamInterval);
          webcamInterval = null;
          webcamToggle.textContent = "Enable webcam";
          moodValues.textContent = "Mood: webcam disabled.";
          return;
        }
        try {
          webcamStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          webcamVideo.srcObject = webcamStream;
          webcamToggle.textContent = "Disable webcam";
          webcamInterval = setInterval(sendMoodFrame, 200);
        } catch (error) {
          moodValues.textContent = `Webcam error: ${error}`;
        }
      }

      async function loadConfig() {
        const response = await fetch("/api/config");
        const config = await response.json();
        cachedConfig = config;
        modeSelect.value = config.mode;
        promptInput.value = config.prompt;
        negativePromptInput.value = config.negative_prompt || "";
        widthInput.value = config.width;
        heightInput.value = config.height;
        const presetValue = `${config.width}x${config.height}`;
        const hasPreset = Array.from(resolutionSelect.options).some((opt) => opt.value === presetValue);
        if (config.output_mode === "upscaled") {
          outputResolutionSelect.value = hasPreset ? presetValue : "3840x2176";
        } else {
          outputResolutionSelect.value = "none";
          resolutionSelect.value = hasPreset ? presetValue : resolutionSelect.options[0]?.value || presetValue;
        }
        applyOutputResolutionToMode();
        seedInput.value = config.seed ?? "";
        dreamStrengthInput.value = config.dream_strength;
        motionInput.value = config.motion;
        promptStrengthInput.value = config.prompt_strength ?? 1.0;
        qualityStepsInput.value = config.quality_steps ?? 8;
        qualityLockToggle.checked = Boolean(config.quality_lock);
        qualityLockStrengthInput.value = config.quality_lock_strength ?? 0.35;
        qualityLockFramesInput.value = config.quality_lock_frames ?? 3;
        dropPrefixFramesInput.value = config.drop_prefix_frames ?? 0;
        promptDriftToggle.checked = Boolean(config.prompt_drift);
        basePromptInput.value = config.base_prompt || "portrait, cinematic lighting";
        identityStrengthInput.value = config.identity_strength ?? 0.7;
        updateQualityControls();
        updateMoodControls();
        updateV2vSecondsOptions();
        currentStreamsCount = config.streams;
        buildStreams(config.streams);
      }

      modeSelect.addEventListener("change", updateMoodControls);
      startButton.addEventListener("click", () => applyConfig({ start: true }));
      applyButton.addEventListener("click", () => applyConfig({ start: false }));
      stopButton.addEventListener("click", stopInference);
      resolutionSelect.addEventListener("change", () => {
        const [w, h] = resolutionSelect.value.split("x").map((v) => parseInt(v, 10));
        if (!Number.isNaN(w) && !Number.isNaN(h)) {
          widthInput.value = w;
          heightInput.value = h;
        }
      });
      outputResolutionSelect.addEventListener("change", applyOutputResolutionToMode);
      qualityLockToggle.addEventListener("change", updateQualityControls);
      webcamToggle.addEventListener("click", toggleWebcam);
      v2vUpload.addEventListener("click", () => v2vFile.click());
      v2vFile.addEventListener("change", () => handleV2vFile(v2vFile.files[0]));
      v2vSubmit.addEventListener("click", submitV2v);
      audioToggle.addEventListener("click", () => {
        if (audioEnabled) {
          stopAudio();
        } else {
          startAudio();
        }
      });
      audioStreamSelect.addEventListener("change", () => {
        lastAudioTs = 0;
        if (audioEnabled) {
          pollAudioStatus();
        }
      });
      settingsApply.addEventListener("click", applySettings);
      settingsReset.addEventListener("click", resetSettings);
      commercialGenerate.addEventListener("click", startCommercialGeneration);
      commercialStop.addEventListener("click", stopCommercialGeneration);

      loadConfig();
      loadSettings();
      applyOutputResolutionToMode();
    </script>
  </body>
</html>
