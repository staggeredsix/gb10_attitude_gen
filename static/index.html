<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LTX-2 Fever Dream + Mood Mirror</title>
    <style>
      body {
        font-family: "Inter", "Segoe UI", sans-serif;
        background: #0b0d14;
        color: #e6e9f2;
        margin: 0;
        padding: 0;
      }
      header {
        padding: 24px 32px;
        background: #131826;
        border-bottom: 1px solid #1f2636;
      }
      main {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 24px;
        padding: 24px 32px;
      }
      .panel {
        background: #121522;
        border-radius: 12px;
        padding: 16px;
        border: 1px solid #1f2636;
      }
      label {
        display: block;
        font-size: 0.85rem;
        margin-top: 12px;
        margin-bottom: 4px;
        color: #b8c0d8;
      }
      input,
      textarea,
      select,
      button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #2b3247;
        background: #0d111c;
        color: #e6e9f2;
      }
      textarea {
        min-height: 70px;
      }
      button {
        background: #4b7bff;
        border: none;
        font-weight: 600;
        cursor: pointer;
      }
      button:hover {
        background: #3b6af0;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 16px;
      }
      .stream {
        background: #0d111c;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid #20263b;
      }
      .stream img {
        width: 100%;
        display: block;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .status {
        margin-top: 12px;
        font-size: 0.85rem;
        color: #9aa4bf;
      }
      .mood-values {
        font-size: 0.85rem;
        margin-top: 6px;
      }
      .toggle-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 12px;
        color: #b8c0d8;
        font-size: 0.85rem;
      }
      .slider-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .slider-value {
        min-width: 48px;
        text-align: right;
        color: #9aa4bf;
        font-size: 0.8rem;
      }
      .settings-item {
        margin-top: 12px;
      }
      .settings-item label {
        margin-top: 0;
      }
      input[type="checkbox"] {
        width: auto;
        padding: 0;
        background: transparent;
        border: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>AI Fever Dream + AI Mood Mirror (LTX-2)</h1>
      <p>Generate looping LTX-2 videos from prompts or mirror your live mood from the webcam.</p>
    </header>
    <main>
      <section class="panel">
        <label for="mode">Mode</label>
        <select id="mode">
          <option value="fever">AI Fever Dream</option>
          <option value="mood">AI Mood Mirror</option>
          <option value="v2v">Video-to-Video (IC-LoRA)</option>
        </select>

        <label for="prompt">Prompt</label>
        <textarea id="prompt"></textarea>

        <label for="negativePrompt">Negative prompt</label>
        <textarea id="negativePrompt" placeholder="e.g., people, faces, text, watermark"></textarea>

        <label for="resolution">Generation resolution</label>
        <select id="resolution">
          <option value="1280x736">1280 × 736 (native max)</option>
          <option value="1024x576">1024 × 576</option>
          <option value="960x544">960 × 544</option>
          <option value="640x384">640 × 384</option>
        </select>

        <label for="outputResolution">Output resolution</label>
        <select id="outputResolution">
          <option value="none">No upscaling</option>
          <option value="1920x1088">1920 × 1088 (1080p-ish)</option>
          <option value="3840x2176">3840 × 2176 (4K-ish)</option>
        </select>

        <div id="dreamControls">
          <div class="row" style="display: none;">
            <div>
              <label for="width">Width</label>
              <input id="width" type="number" min="256" step="32" disabled />
            </div>
            <div>
              <label for="height">Height</label>
              <input id="height" type="number" min="256" step="32" disabled />
            </div>
          </div>

          <label for="seed">Seed (optional)</label>
          <input id="seed" type="number" placeholder="Leave empty for random" />

          <label class="slider-row" for="dreamStrength">
            <span>Dream strength</span>
            <span class="slider-value" id="dreamStrengthValue"></span>
          </label>
          <input id="dreamStrength" type="range" min="0" max="1" step="0.01" value="0" />

          <label class="slider-row" for="motion">
            <span>Motion</span>
            <span class="slider-value" id="motionValue"></span>
          </label>
          <input id="motion" type="range" min="0" max="1" step="0.01" />

          <label class="slider-row" for="promptStrength">
            <span>Prompt Strength</span>
            <span class="slider-value" id="promptStrengthValue"></span>
          </label>
          <input id="promptStrength" type="range" min="0.8" max="2" step="0.01" value="1" />

          <label class="slider-row" for="qualitySteps">
            <span>Steps</span>
            <span class="slider-value" id="qualityStepsValue"></span>
          </label>
          <input id="qualitySteps" type="range" min="4" max="24" step="1" value="8" />

          <label class="toggle-row">
            <input id="qualityLock" type="checkbox" />
            Quality Lock
          </label>

          <div id="qualityLockControls" style="display: none;">
            <label class="slider-row" for="qualityLockStrength">
              <span>Lock Strength</span>
              <span class="slider-value" id="qualityLockStrengthValue"></span>
            </label>
            <input id="qualityLockStrength" type="range" min="0.1" max="0.7" step="0.01" value="0.35" />

            <label class="slider-row" for="qualityLockFrames">
              <span>Anchor Frames</span>
              <span class="slider-value" id="qualityLockFramesValue"></span>
            </label>
            <input id="qualityLockFrames" type="range" min="1" max="6" step="1" value="3" />

            <label class="slider-row" for="dropPrefixFrames">
              <span>Drop Prefix Frames</span>
              <span class="slider-value" id="dropPrefixFramesValue"></span>
            </label>
            <input id="dropPrefixFrames" type="range" min="0" max="4" step="1" value="0" />
          </div>

          <label class="toggle-row">
            <input id="promptDrift" type="checkbox" />
            Prompt Drift
          </label>

          <div id="moodControls">
            <label for="basePrompt">Mood Mirror base prompt</label>
            <textarea id="basePrompt"></textarea>

            <label class="slider-row" for="identityStrength">
              <span>Retain identity → Abstract mirror</span>
              <span class="slider-value" id="identityStrengthValue"></span>
            </label>
            <input id="identityStrength" type="range" min="0" max="1" step="0.01" />

            <button id="webcamToggle" type="button">Enable webcam</button>
            <div class="mood-values" id="moodValues">Mood: waiting for camera…</div>
          </div>

          <div class="row">
            <button id="startButton" type="button">Start dreaming</button>
            <button id="applyButton" type="button">Update dream</button>
            <button id="stopButton" type="button">Stop dreaming</button>
          </div>
          <div class="status" id="status"></div>
        </div>
      </section>

      <section class="panel" id="settingsPanel">
        <h3>Runtime Settings (settings.conf)</h3>
        <div class="status" id="settingsStatus"></div>
        <div id="settingsList"></div>
        <div class="row" style="margin-top: 12px;">
          <button id="settingsApply" type="button">Apply settings</button>
          <button id="settingsReset" type="button">Reset defaults</button>
        </div>
      </section>

      <section class="panel" id="streamsPanel">
        <h3 id="streamsHeading">Streams</h3>
        <div class="grid" id="streamGrid"></div>
      </section>

      <section class="panel" id="v2vPanel">
        <h3>Video-to-Video (IC-LoRA)</h3>
        <button id="v2vUpload" type="button">Upload Video</button>
        <input id="v2vFile" type="file" accept="video/*" style="display: none;" />
        <div class="status">
          Uses the main prompt + negative prompt above. Fixed 24 fps. “Stitched” means multiple shorter
          generations are created and concatenated to reach longer durations.
        </div>
        <div class="row">
          <div>
            <label for="v2vStrength">Dreaming</label>
          <input id="v2vStrength" type="range" min="0" max="1" step="0.01" value="0.7" />
          </div>
          <div>
            <label for="v2vSeconds">Seconds</label>
            <select id="v2vSeconds">
              <option value="10">10</option>
              <option value="30">30</option>
              <option value="60">60</option>
              <option value="120">120</option>
              <option value="360">360</option>
            </select>
          </div>
        </div>
        <button id="v2vSubmit" type="button">Generate Video</button>
        <div class="status" id="v2vStatus"></div>
        <video id="v2vPreview" controls style="width: 100%; margin-top: 8px; display: none;"></video>
      </section>
    </main>

    <video id="webcamVideo" autoplay playsinline style="display: none;"></video>
    <canvas id="webcamCanvas" width="640" height="360" style="display: none;"></canvas>

    <script>
      const modeSelect = document.getElementById("mode");
      const promptInput = document.getElementById("prompt");
      const negativePromptInput = document.getElementById("negativePrompt");
      const resolutionSelect = document.getElementById("resolution");
      const outputResolutionSelect = document.getElementById("outputResolution");
      const dreamControls = document.getElementById("dreamControls");
      const widthInput = document.getElementById("width");
      const heightInput = document.getElementById("height");
      const seedInput = document.getElementById("seed");
      const dreamStrengthInput = document.getElementById("dreamStrength");
      const motionInput = document.getElementById("motion");
      const promptStrengthInput = document.getElementById("promptStrength");
      const qualityStepsInput = document.getElementById("qualitySteps");
      const qualityLockToggle = document.getElementById("qualityLock");
      const qualityLockControls = document.getElementById("qualityLockControls");
      const qualityLockStrengthInput = document.getElementById("qualityLockStrength");
      const qualityLockFramesInput = document.getElementById("qualityLockFrames");
      const dropPrefixFramesInput = document.getElementById("dropPrefixFrames");
      const promptDriftToggle = document.getElementById("promptDrift");
      const dreamStrengthValue = document.getElementById("dreamStrengthValue");
      const motionValue = document.getElementById("motionValue");
      const promptStrengthValue = document.getElementById("promptStrengthValue");
      const qualityStepsValue = document.getElementById("qualityStepsValue");
      const qualityLockStrengthValue = document.getElementById("qualityLockStrengthValue");
      const qualityLockFramesValue = document.getElementById("qualityLockFramesValue");
      const dropPrefixFramesValue = document.getElementById("dropPrefixFramesValue");
      const identityStrengthValue = document.getElementById("identityStrengthValue");
      const moodControls = document.getElementById("moodControls");
      const basePromptInput = document.getElementById("basePrompt");
      const identityStrengthInput = document.getElementById("identityStrength");
      const webcamToggle = document.getElementById("webcamToggle");
      const moodValues = document.getElementById("moodValues");
      const webcamVideo = document.getElementById("webcamVideo");
      const webcamCanvas = document.getElementById("webcamCanvas");
      const webcamCtx = webcamCanvas.getContext("2d");
      const applyButton = document.getElementById("applyButton");
      const startButton = document.getElementById("startButton");
      const stopButton = document.getElementById("stopButton");
      const status = document.getElementById("status");
      const streamsHeading = document.getElementById("streamsHeading");
      const streamGrid = document.getElementById("streamGrid");
      const streamsPanel = document.getElementById("streamsPanel");
      const v2vPanel = document.getElementById("v2vPanel");
      const settingsPanel = document.getElementById("settingsPanel");
      const settingsList = document.getElementById("settingsList");
      const settingsStatus = document.getElementById("settingsStatus");
      const settingsApply = document.getElementById("settingsApply");
      const settingsReset = document.getElementById("settingsReset");
      const v2vUpload = document.getElementById("v2vUpload");
      const v2vFile = document.getElementById("v2vFile");
      const v2vStrength = document.getElementById("v2vStrength");
      const v2vSeconds = document.getElementById("v2vSeconds");
      const v2vSubmit = document.getElementById("v2vSubmit");
      const v2vStatus = document.getElementById("v2vStatus");
      const v2vPreview = document.getElementById("v2vPreview");
      const V2V_FPS = 24;
      const v2vSecondsPresets = [10, 30, 60, 120, 360];
      const v2vMaxFrames = 257;
      const v2vTotalMaxFrames = 8640;
      let cachedConfig = null;
      let currentStreamsCount = 1;
      let webcamStream = null;
      let webcamInterval = null;

      function setStatus(message) {
        status.textContent = message;
      }

      function setSettingsStatus(message) {
        settingsStatus.textContent = message;
      }

      function setV2vStatus(message) {
        v2vStatus.textContent = message;
      }

      function adjustV2vFrames(targetFrames) {
        const target = Math.max(1, Math.round(targetFrames || 1));
        const k = Math.round((target - 1) / 8);
        return Math.max(1, 1 + 8 * k);
      }

      function updateV2vSecondsOptions() {
        const fps = V2V_FPS;
        v2vSeconds.innerHTML = "";
        let firstEnabled = null;
        for (const seconds of v2vSecondsPresets) {
          const targetFrames = seconds * fps;
          const adjustedFrames = adjustV2vFrames(targetFrames);
          const actualSeconds = adjustedFrames / fps;
          const option = document.createElement("option");
          option.value = String(seconds);
          option.dataset.frames = String(adjustedFrames);
          option.dataset.actualSeconds = actualSeconds.toFixed(2);
          if (adjustedFrames > v2vTotalMaxFrames) {
            option.disabled = true;
            option.textContent = `${seconds}s (too long)`;
          } else if (adjustedFrames > v2vMaxFrames) {
            option.textContent = `${seconds}s (~${actualSeconds.toFixed(1)}s, stitched)`;
            if (!firstEnabled) {
              firstEnabled = option;
            }
          } else {
            option.textContent = `${seconds}s (~${actualSeconds.toFixed(1)}s)`;
            if (!firstEnabled) {
              firstEnabled = option;
            }
          }
          v2vSeconds.appendChild(option);
        }
        if (firstEnabled) {
          firstEnabled.selected = true;
        }
      }

      function updateMoodControls() {
        v2vPanel.style.display = modeSelect.value === "v2v" ? "block" : "none";
        const v2vActive = modeSelect.value === "v2v";
        startButton.disabled = v2vActive;
        applyButton.disabled = v2vActive;
        dreamControls.style.display = v2vActive ? "none" : "block";
        streamsPanel.style.display = v2vActive ? "none" : "block";
        streamsHeading.textContent = v2vActive ? "Video-to-Video Output" : "Streams";
        moodControls.style.display = modeSelect.value === "mood" ? "block" : "none";
      }

      function updateQualityControls() {
        const enabled = qualityLockToggle.checked;
        qualityLockControls.style.display = enabled ? "block" : "none";
        if (enabled) {
          promptDriftToggle.checked = false;
          promptDriftToggle.disabled = true;
        } else {
          promptDriftToggle.disabled = false;
        }
      }

      function updateSliderValues() {
        dreamStrengthValue.textContent = Number(dreamStrengthInput.value || 0).toFixed(2);
        motionValue.textContent = Number(motionInput.value || 0).toFixed(2);
        promptStrengthValue.textContent = Number(promptStrengthInput.value || 0).toFixed(2);
        qualityStepsValue.textContent = String(parseInt(qualityStepsInput.value || "0", 10));
        qualityLockStrengthValue.textContent = Number(qualityLockStrengthInput.value || 0).toFixed(2);
        qualityLockFramesValue.textContent = String(parseInt(qualityLockFramesInput.value || "0", 10));
        dropPrefixFramesValue.textContent = String(parseInt(dropPrefixFramesInput.value || "0", 10));
        identityStrengthValue.textContent = Number(identityStrengthInput.value || 0).toFixed(2);
      }

      function inferSettingRange(key, value) {
        const upper = key.toUpperCase();
        const numeric = Number(value);
        const isNumeric = !Number.isNaN(numeric);
        const boolHints = ["ENABLE", "DISABLE", "SKIP", "PERSIST", "USE_", "AUTOSTART", "CHAINING", "DROP_", "PROMPT_DRIFT"];
        if (boolHints.some((hint) => upper.includes(hint)) && (value === "0" || value === "1")) {
          return { min: 0, max: 1, step: 1, value: Number(value) };
        }
        if (!isNumeric) {
          return { min: 0, max: 1, step: 1, value: 0 };
        }
        if (upper.includes("WIDTH") || upper.includes("HEIGHT")) {
          return { min: 64, max: 8192, step: 32, value: numeric };
        }
        if (upper.includes("FPS")) {
          return { min: 1, max: 60, step: 1, value: numeric };
        }
        if (upper.includes("SECONDS")) {
          const max = Math.max(10, Math.ceil(numeric * 2));
          return { min: 0, max, step: 0.1, value: numeric };
        }
        if (upper.includes("FRAMES")) {
          const max = Math.max(16, Math.ceil(numeric * 2));
          return { min: 0, max, step: 1, value: numeric };
        }
        if (upper.includes("STEPS")) {
          return { min: 0, max: 200, step: 1, value: numeric };
        }
        if (upper.includes("CFG")) {
          return { min: 0, max: 2, step: 0.01, value: numeric };
        }
        if (upper.includes("STRENGTH")) {
          const max = numeric > 1 ? 2 : 1;
          return { min: 0, max, step: 0.01, value: numeric };
        }
        if (Number.isInteger(numeric)) {
          const max = Math.max(10, Math.ceil(numeric * 2));
          return { min: 0, max, step: 1, value: numeric };
        }
        const max = Math.max(1, Math.ceil(numeric * 2));
        return { min: 0, max, step: 0.01, value: numeric };
      }

      function formatSettingValue(slider) {
        const step = parseFloat(slider.step || "1");
        if (step >= 1) {
          return String(parseInt(slider.value || "0", 10));
        }
        return Number(slider.value || 0).toFixed(2);
      }

      function buildSettingsList(items) {
        settingsList.innerHTML = "";
        items.forEach((item) => {
          const wrapper = document.createElement("div");
          wrapper.className = "settings-item";
          const range = inferSettingRange(item.key, item.value === "" ? "0" : item.value);
          const label = document.createElement("label");
          label.className = "slider-row";
          label.htmlFor = `setting-${item.key}`;
          const labelText = document.createElement("span");
          labelText.textContent = item.key;
          const valueText = document.createElement("span");
          valueText.className = "slider-value";
          label.appendChild(labelText);
          label.appendChild(valueText);
          const slider = document.createElement("input");
          slider.type = "range";
          slider.id = `setting-${item.key}`;
          slider.dataset.key = item.key;
          slider.dataset.emptyAllowed = item.empty_allowed ? "1" : "0";
          slider.min = String(range.min);
          slider.max = String(range.max);
          slider.step = String(range.step);
          slider.value = String(range.value);
          valueText.textContent = formatSettingValue(slider);
          slider.addEventListener("input", () => {
            valueText.textContent = formatSettingValue(slider);
          });
          wrapper.appendChild(label);
          wrapper.appendChild(slider);
          settingsList.appendChild(wrapper);
        });
      }

      async function loadSettings() {
        try {
          const response = await fetch("/api/settings");
          if (!response.ok) {
            setSettingsStatus("Failed to load settings.");
            return;
          }
          const data = await response.json();
          buildSettingsList(data.settings || []);
          setSettingsStatus("");
        } catch (err) {
          setSettingsStatus(`Error: ${err}`);
        }
      }

      async function applySettings() {
        const updates = {};
        const sliders = settingsList.querySelectorAll("input[type='range']");
        sliders.forEach((slider) => {
          const key = slider.dataset.key;
          if (!key) return;
          const emptyAllowed = slider.dataset.emptyAllowed === "1";
          if (emptyAllowed && Number(slider.value) === 0) {
            updates[key] = "";
            return;
          }
          updates[key] = slider.value;
        });
        setSettingsStatus("Applying settings...");
        try {
          const response = await fetch("/api/settings", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ settings: updates }),
          });
          if (!response.ok) {
            const data = await response.json();
            setSettingsStatus(`Error: ${data.detail || "update failed"}`);
            return;
          }
          setSettingsStatus("Settings applied.");
        } catch (err) {
          setSettingsStatus(`Error: ${err}`);
        }
      }

      async function resetSettings() {
        setSettingsStatus("Resetting defaults...");
        try {
          const response = await fetch("/api/settings/reset", { method: "POST" });
          if (!response.ok) {
            const data = await response.json();
            setSettingsStatus(`Error: ${data.detail || "reset failed"}`);
            return;
          }
          await loadSettings();
          setSettingsStatus("Defaults restored.");
        } catch (err) {
          setSettingsStatus(`Error: ${err}`);
        }
      }

      function resolveOutputSettings() {
        if (outputResolutionSelect.value === "none") {
          return {
            output_mode: "native",
          };
        }
        return {
          output_mode: "upscaled",
        };
      }

      function applyOutputResolutionToMode() {
        if (outputResolutionSelect.value === "none") {
          resolutionSelect.disabled = false;
          const [w, h] = resolutionSelect.value.split("x").map((v) => parseInt(v, 10));
          if (!Number.isNaN(w) && !Number.isNaN(h)) {
            widthInput.value = w;
            heightInput.value = h;
          }
          return;
        }
        resolutionSelect.disabled = true;
        const [ow, oh] = outputResolutionSelect.value.split("x").map((v) => parseInt(v, 10));
        if (!Number.isNaN(ow) && !Number.isNaN(oh)) {
          widthInput.value = ow;
          heightInput.value = oh;
        }
      }

      function buildConfig() {
        const outputSettings = resolveOutputSettings();
        const fallback = cachedConfig || {};
        return {
          mode: modeSelect.value,
          prompt: promptInput.value.trim(),
          negative_prompt: negativePromptInput.value.trim(),
          width: parseInt(widthInput.value, 10),
          height: parseInt(heightInput.value, 10),
          fps: fallback.fps ?? 24,
          streams: fallback.streams ?? 1,
          output_mode: outputSettings.output_mode,
          seed: seedInput.value ? parseInt(seedInput.value, 10) : null,
          dream_strength: parseFloat(dreamStrengthInput.value),
          motion: parseFloat(motionInput.value),
          prompt_strength: parseFloat(promptStrengthInput.value),
          quality_steps: parseInt(qualityStepsInput.value, 10),
          quality_lock: qualityLockToggle.checked,
          quality_lock_strength: parseFloat(qualityLockStrengthInput.value),
          quality_lock_frames: parseInt(qualityLockFramesInput.value, 10),
          drop_prefix_frames: parseInt(dropPrefixFramesInput.value, 10),
          prompt_drift: promptDriftToggle.checked,
          base_prompt: basePromptInput.value.trim() || fallback.base_prompt || "portrait, cinematic lighting",
          identity_strength: parseFloat(identityStrengthInput.value || String(fallback.identity_strength ?? 0.7)),
          audio_enabled: false,
        };
      }

      async function applyConfig({ start = false } = {}) {
        if (modeSelect.value === "v2v") {
          setStatus("V2V uses the panel below. Start/Update are disabled in V2V mode.");
          return;
        }
        setStatus(start ? "Starting dream..." : "Updating dream...");
        const config = buildConfig();
        const response = await fetch("/api/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(config),
        });
        if (!response.ok) {
          const data = await response.json();
          setStatus(`Error: ${data.detail}`);
          return;
        }
        const updated = await response.json();
        if (start) {
          await fetch("/api/start", { method: "POST" });
        }
        setStatus(start ? "Dream started." : "Dream updated.");
        if (updated.streams !== currentStreamsCount) {
          currentStreamsCount = updated.streams;
          buildStreams(updated.streams);
        }
      }

      function buildStreams(count) {
        streamGrid.innerHTML = "";
        const columns = count <= 1 ? 1 : 2;
        streamGrid.style.gridTemplateColumns = `repeat(${columns}, minmax(0, 1fr))`;
        for (let i = 0; i < count; i++) {
          const wrapper = document.createElement("div");
          wrapper.className = "stream";
          const img = document.createElement("img");
          img.src = `/stream/${i}.mjpg?ts=${Date.now()}`;
          wrapper.appendChild(img);
          streamGrid.appendChild(wrapper);
        }
      }

      function handleV2vFile(file) {
        if (!file) {
          return;
        }
        const dt = new DataTransfer();
        dt.items.add(file);
        v2vFile.files = dt.files;
        setV2vStatus(`Selected: ${file.name}`);
      }

      async function submitV2v() {
        const file = v2vFile.files[0];
        if (!file) {
          setV2vStatus("Please select a video file.");
          return;
        }
        if (!promptInput.value.trim()) {
          setV2vStatus("Please enter a prompt.");
          return;
        }
        const fps = V2V_FPS;
        const seconds = parseFloat(v2vSeconds.value || "0");
        const targetFrames = seconds * fps;
        const adjustedFrames = adjustV2vFrames(targetFrames);
        const actualSeconds = adjustedFrames / fps;
        setV2vStatus(`Generating ~${actualSeconds.toFixed(1)}s (${adjustedFrames} frames @ ${fps} fps)...`);
        const form = new FormData();
        form.append("file", file);
        form.append("prompt", promptInput.value.trim());
        form.append("negative_prompt", negativePromptInput.value.trim());
        form.append("strength", String(v2vStrength.value || "0.7"));
        form.append("seconds", String(seconds || "0"));
        form.append("num_frames", String(adjustedFrames));
        form.append("fps", String(fps));
        try {
          const response = await fetch("/api/v2v", { method: "POST", body: form });
          if (!response.ok) {
            const data = await response.json();
            setV2vStatus(`Error: ${data.detail || "request failed"}`);
            return;
          }
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          v2vPreview.src = url;
          v2vPreview.style.display = "block";
          setV2vStatus("Done.");
        } catch (err) {
          setV2vStatus(`Error: ${err}`);
        }
      }

      async function stopInference() {
        setStatus("Stopping dream...");
        try {
          const response = await fetch("/api/stop", { method: "POST" });
          if (!response.ok) {
            const data = await response.json();
            setStatus(`Error: ${data.detail || "stop failed"}`);
            return;
          }
          setStatus("Dream stopped.");
        } catch (err) {
          setStatus(`Error: ${err}`);
        }
      }

      async function sendMoodFrame() {
        if (!webcamStream) {
          return;
        }
        webcamCanvas.width = webcamVideo.videoWidth || 640;
        webcamCanvas.height = webcamVideo.videoHeight || 360;
        webcamCtx.drawImage(webcamVideo, 0, 0, webcamCanvas.width, webcamCanvas.height);
        const blob = await new Promise((resolve) => webcamCanvas.toBlob(resolve, "image/jpeg", 0.7));
        if (!blob) return;
        const response = await fetch("/api/mood/frame", { method: "POST", body: blob });
        if (response.ok) {
          const mood = await response.json();
          moodValues.textContent = `Mood: valence ${mood.valence.toFixed(2)} | arousal ${mood.arousal.toFixed(2)} | ${
            mood.labels.join(", ") || "neutral"
          }`;
        }
      }

      async function toggleWebcam() {
        if (webcamStream) {
          webcamStream.getTracks().forEach((track) => track.stop());
          webcamStream = null;
          clearInterval(webcamInterval);
          webcamInterval = null;
          webcamToggle.textContent = "Enable webcam";
          moodValues.textContent = "Mood: webcam disabled.";
          return;
        }
        try {
          webcamStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          webcamVideo.srcObject = webcamStream;
          webcamToggle.textContent = "Disable webcam";
          webcamInterval = setInterval(sendMoodFrame, 200);
        } catch (error) {
          moodValues.textContent = `Webcam error: ${error}`;
        }
      }

      async function loadConfig() {
        const response = await fetch("/api/config");
        const config = await response.json();
        cachedConfig = config;
        modeSelect.value = config.mode;
        promptInput.value = config.prompt;
        negativePromptInput.value = config.negative_prompt || "";
        widthInput.value = config.width;
        heightInput.value = config.height;
        const presetValue = `${config.width}x${config.height}`;
        const hasPreset = Array.from(resolutionSelect.options).some((opt) => opt.value === presetValue);
        if (config.output_mode === "upscaled") {
          outputResolutionSelect.value = hasPreset ? presetValue : "3840x2176";
        } else {
          outputResolutionSelect.value = "none";
          resolutionSelect.value = hasPreset ? presetValue : resolutionSelect.options[0]?.value || presetValue;
        }
        applyOutputResolutionToMode();
        seedInput.value = config.seed ?? "";
        dreamStrengthInput.value = config.dream_strength;
        motionInput.value = config.motion;
        promptStrengthInput.value = config.prompt_strength ?? 1.0;
        qualityStepsInput.value = config.quality_steps ?? 8;
        qualityLockToggle.checked = Boolean(config.quality_lock);
        qualityLockStrengthInput.value = config.quality_lock_strength ?? 0.35;
        qualityLockFramesInput.value = config.quality_lock_frames ?? 3;
        dropPrefixFramesInput.value = config.drop_prefix_frames ?? 0;
        promptDriftToggle.checked = Boolean(config.prompt_drift);
        basePromptInput.value = config.base_prompt || "portrait, cinematic lighting";
        identityStrengthInput.value = config.identity_strength ?? 0.7;
        updateSliderValues();
        updateQualityControls();
        updateMoodControls();
        updateV2vSecondsOptions();
        currentStreamsCount = config.streams;
        buildStreams(config.streams);
      }

      modeSelect.addEventListener("change", updateMoodControls);
      startButton.addEventListener("click", () => applyConfig({ start: true }));
      applyButton.addEventListener("click", () => applyConfig({ start: false }));
      stopButton.addEventListener("click", stopInference);
      dreamStrengthInput.addEventListener("input", updateSliderValues);
      motionInput.addEventListener("input", updateSliderValues);
      promptStrengthInput.addEventListener("input", updateSliderValues);
      qualityStepsInput.addEventListener("input", updateSliderValues);
      qualityLockStrengthInput.addEventListener("input", updateSliderValues);
      qualityLockFramesInput.addEventListener("input", updateSliderValues);
      dropPrefixFramesInput.addEventListener("input", updateSliderValues);
      identityStrengthInput.addEventListener("input", updateSliderValues);
      resolutionSelect.addEventListener("change", () => {
        const [w, h] = resolutionSelect.value.split("x").map((v) => parseInt(v, 10));
        if (!Number.isNaN(w) && !Number.isNaN(h)) {
          widthInput.value = w;
          heightInput.value = h;
        }
      });
      outputResolutionSelect.addEventListener("change", applyOutputResolutionToMode);
      qualityLockToggle.addEventListener("change", updateQualityControls);
      webcamToggle.addEventListener("click", toggleWebcam);
      v2vUpload.addEventListener("click", () => v2vFile.click());
      v2vFile.addEventListener("change", () => handleV2vFile(v2vFile.files[0]));
      v2vSubmit.addEventListener("click", submitV2v);
      settingsApply.addEventListener("click", applySettings);
      settingsReset.addEventListener("click", resetSettings);

      loadConfig();
      loadSettings();
      applyOutputResolutionToMode();
      updateSliderValues();
    </script>
  </body>
</html>
